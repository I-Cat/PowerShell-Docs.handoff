{"nodes":[{"content":"Script Tracing and Logging","pos":[2,28]},{"content":"While Windows PowerShell already has the <bpt id=\"p1\">**</bpt>LogPipelineExecutionDetails<ept id=\"p1\">**</ept> Group Policy setting to log the invocation of cmdlets, PowerShell’s scripting language has plenty of features that you might want to log and/or audit.","pos":[30,253],"source":"While Windows PowerShell already has the **LogPipelineExecutionDetails** Group Policy setting to log the invocation of cmdlets, PowerShell’s scripting language has plenty of features that you might want to log and/or audit."},{"content":"The new Detailed Script Tracing feature lets you enable detailed tracking and analysis of Windows PowerShell scripting use on a system.","pos":[254,389]},{"content":"After you enable detailed script tracing, Windows PowerShell logs all script blocks to the ETW event log, <bpt id=\"p1\">**</bpt>Microsoft-Windows-PowerShell/Operational<ept id=\"p1\">**</ept>.","pos":[390,541],"source":" After you enable detailed script tracing, Windows PowerShell logs all script blocks to the ETW event log, **Microsoft-Windows-PowerShell/Operational**."},{"content":"If a script block creates another script block (for example, a script that calls the Invoke-Expression cmdlet on a string), that resulting script block is logged as well.","pos":[542,712]},{"pos":[714,904],"content":"Logging of these events can be enabled through the <bpt id=\"p1\">**</bpt>Turn on PowerShell Script Block Logging<ept id=\"p1\">**</ept> Group Policy setting (in Administrative Templates -&gt; Windows Components -&gt; Windows PowerShell).","source":"Logging of these events can be enabled through the **Turn on PowerShell Script Block Logging** Group Policy setting (in Administrative Templates -> Windows Components -> Windows PowerShell)."},{"content":"The events are:","pos":[906,921]},{"content":"Channel","pos":[925,932]},{"content":"Operational","pos":[935,946]},{"content":"Level","pos":[1041,1046]},{"content":"Verbose","pos":[1051,1058]},{"content":"Opcode","pos":[1099,1105]},{"content":"Create","pos":[1109,1115]},{"content":"Task","pos":[1157,1161]},{"content":"CommandStart","pos":[1167,1179]},{"content":"Keyword","pos":[1215,1222]},{"content":"Runspace","pos":[1225,1233]},{"content":"EventId","pos":[1273,1280]},{"content":"Engine_ScriptBlockCompiled (0x1008 = 4104)","pos":[1283,1325]},{"content":"Message","pos":[1331,1338]},{"content":"Creating Scriptblock text (%1 of %2):","pos":[1341,1378]},{"content":"%3","pos":[1385,1387]},{"content":"ScriptBlock ID: %4","pos":[1394,1412]},{"content":"The text embedded in the message is the extent of the script block compiled.","pos":[1417,1493]},{"content":"The ID is a GUID that is retained for the life of the script block.","pos":[1494,1561]},{"content":"When you enable verbose logging, the feature writes begin and end markers:","pos":[1563,1637]},{"content":"Channel","pos":[1641,1648]},{"content":"Operational","pos":[1651,1662]},{"content":"Level","pos":[1779,1784]},{"content":"Verbose","pos":[1789,1796]},{"content":"Opcode","pos":[1848,1854]},{"content":"Open (/ Close)","pos":[1858,1872]},{"content":"Task","pos":[1917,1921]},{"content":"CommandStart (/ CommandStop)","pos":[1927,1955]},{"content":"Keyword","pos":[1986,1993]},{"content":"Runspace","pos":[1996,2004]},{"content":"EventId","pos":[2055,2062]},{"content":"ScriptBlock\\_Invoke\\_Start\\_Detail (0x1009 = 4105) /","pos":[2065,2117]},{"content":"ScriptBlock\\_Invoke\\_Complete\\_Detail (0x100A = 4106)","pos":[2124,2177]},{"content":"Message","pos":[2182,2189]},{"content":"Started (/ Completed) invocation of ScriptBlock ID: %1","pos":[2192,2246]},{"content":"Runspace ID: %2","pos":[2253,2268]},{"content":"The ID is the GUID representing the script block (that can be correlated with event ID 0x1008), and the Runspace ID represents the runspace in which this script block was run.","pos":[2272,2447]},{"content":"Percent signs in the invocation message represent structured ETW properties.","pos":[2449,2525]},{"content":"While they are replaced with the actual values in the message text, a more robust way to access them is to retrieve the message with the Get-WinEvent cmdlet, and then use the <bpt id=\"p1\">**</bpt>Properties<ept id=\"p1\">**</ept> array of the message.","pos":[2526,2737],"source":" While they are replaced with the actual values in the message text, a more robust way to access them is to retrieve the message with the Get-WinEvent cmdlet, and then use the **Properties** array of the message."},{"content":"Here's an example of how this functionality can help unwrap a malicious attempt to encrypt and obfuscate a script:","pos":[2739,2853]},{"content":"Running this generates the following log entries:","pos":[3330,3379]},{"content":"If the script block length exceeds what ETW is capable of holding in a single event, Windows PowerShell breaks the script into multiple parts.","pos":[4202,4344]},{"content":"Here is sample code to recombine a script from its log messages:","pos":[4345,4409]},{"content":"As with all logging systems that have a limited retention buffer (i.e. ETW logs), one attack against this infrastructure is to flood the log with spurious events to hide earlier evidence.","pos":[4689,4876]},{"content":"To protect yourself from this attack, ensure that you have some form of event log collection set up (i.e., Windows Event Forwarding, <bpt id=\"p1\">[</bpt>Spotting the Adversary with Windows Event Log Monitoring<ept id=\"p1\">](http://www.nsa.gov/ia/_files/app/Spotting_the_Adversary_with_Windows_Event_Log_Monitoring.pdf)</ept>) to move event logs off of the computer as soon as possible.","pos":[4877,5224],"source":" To protect yourself from this attack, ensure that you have some form of event log collection set up (i.e., Windows Event Forwarding, [Spotting the Adversary with Windows Event Log Monitoring](http://www.nsa.gov/ia/_files/app/Spotting_the_Adversary_with_Windows_Event_Log_Monitoring.pdf)) to move event logs off of the computer as soon as possible."}],"content":"# Script Tracing and Logging\n\nWhile Windows PowerShell already has the **LogPipelineExecutionDetails** Group Policy setting to log the invocation of cmdlets, PowerShell’s scripting language has plenty of features that you might want to log and/or audit. The new Detailed Script Tracing feature lets you enable detailed tracking and analysis of Windows PowerShell scripting use on a system. After you enable detailed script tracing, Windows PowerShell logs all script blocks to the ETW event log, **Microsoft-Windows-PowerShell/Operational**. If a script block creates another script block (for example, a script that calls the Invoke-Expression cmdlet on a string), that resulting script block is logged as well.\n\nLogging of these events can be enabled through the **Turn on PowerShell Script Block Logging** Group Policy setting (in Administrative Templates -> Windows Components -> Windows PowerShell).\n\nThe events are:\n\n| Channel | Operational                                 |\n|---------|---------------------------------------------|\n| Level   | Verbose                                     |\n| Opcode  | Create                                      |\n| Task    | CommandStart                                |\n| Keyword | Runspace                                    |\n| EventId | Engine_ScriptBlockCompiled (0x1008 = 4104)  |\n| Message | Creating Scriptblock text (%1 of %2): </br> %3 </br> ScriptBlock ID: %4 |\n\n\nThe text embedded in the message is the extent of the script block compiled. The ID is a GUID that is retained for the life of the script block.\n\nWhen you enable verbose logging, the feature writes begin and end markers:\n\n| Channel | Operational                                            |\n|---------|--------------------------------------------------------|\n| Level   | Verbose                                                |\n| Opcode  | Open (/ Close)                                         |\n| Task    | CommandStart (/ CommandStop)                           |\n| Keyword | Runspace                                               |\n| EventId | ScriptBlock\\_Invoke\\_Start\\_Detail (0x1009 = 4105) / </br> ScriptBlock\\_Invoke\\_Complete\\_Detail (0x100A = 4106) |\n| Message | Started (/ Completed) invocation of ScriptBlock ID: %1 </br> Runspace ID: %2 |\n\nThe ID is the GUID representing the script block (that can be correlated with event ID 0x1008), and the Runspace ID represents the runspace in which this script block was run.\n\nPercent signs in the invocation message represent structured ETW properties. While they are replaced with the actual values in the message text, a more robust way to access them is to retrieve the message with the Get-WinEvent cmdlet, and then use the **Properties** array of the message.\n\nHere's an example of how this functionality can help unwrap a malicious attempt to encrypt and obfuscate a script:\n\n```powershell\n## Malware\nfunction SuperDecrypt\n{\n    param($script)\n    $bytes = [Convert]::FromBase64String($script)\n             \n    ## XOR “encryption”\n    $xorKey = 0x42\n    for($counter = 0; $counter -lt $bytes.Length; $counter++)\n    {\n        $bytes[$counter] = $bytes[$counter] -bxor $xorKey\n    }\n    [System.Text.Encoding]::Unicode.GetString($bytes)\n}\n\n$decrypted = SuperDecrypt \"FUIwQitCNkInQm9CCkItQjFCNkJiQmVCEkI1QixCJkJlQg==\"\nInvoke-Expression $decrypted\n```\n\nRunning this generates the following log entries:\n\n```\nCompiling Scriptblock text (1 of 1):\nfunction SuperDecrypt\n{\n    param($script)\n    $bytes = [Convert]::FromBase64String($script)\n    ## XOR \"encryption\"\n    $xorKey = 0x42\n    for($counter = 0; $counter -lt $bytes.Length; $counter++)\n    {\n        $bytes[$counter] = $bytes[$counter] -bxor $xorKey\n    }\n    [System.Text.Encoding]::Unicode.GetString($bytes)\n\n}\nScriptBlock ID: ad8ae740-1f33-42aa-8dfc-1314411877e3\n\nCompiling Scriptblock text (1 of 1):\n$decrypted = SuperDecrypt \"FUIwQitCNkInQm9CCkItQjFCNkJiQmVCEkI1QixCJkJlQg==\"\nScriptBlock ID: ba11c155-d34c-4004-88e3-6502ecb50f52\n\nCompiling Scriptblock text (1 of 1):\nInvoke-Expression $decrypted\nScriptBlock ID: 856c01ca-85d7-4989-b47f-e6a09ee4eeb3\n\nCompiling Scriptblock text (1 of 1):\nWrite-Host 'Pwnd'\nScriptBlock ID: 5e618414-4e77-48e3-8f65-9a863f54b4c8\n```\n\nIf the script block length exceeds what ETW is capable of holding in a single event, Windows PowerShell breaks the script into multiple parts. Here is sample code to recombine a script from its log messages:\n\n```powershell\n$created = Get-WinEvent -FilterHashtable @{ ProviderName=\"Microsoft-Windows-PowerShell\"; Id = 4104 } | Where-Object { $_.<...> }\n$sortedScripts = $created | sort { $_.Properties[0].Value }\n$mergedScript = -join ($sortedScripts | % { $_.Properties[2].Value })\n```\n\nAs with all logging systems that have a limited retention buffer (i.e. ETW logs), one attack against this infrastructure is to flood the log with spurious events to hide earlier evidence. To protect yourself from this attack, ensure that you have some form of event log collection set up (i.e., Windows Event Forwarding, [Spotting the Adversary with Windows Event Log Monitoring](http://www.nsa.gov/ia/_files/app/Spotting_the_Adversary_with_Windows_Event_Log_Monitoring.pdf)) to move event logs off of the computer as soon as possible.\n"}