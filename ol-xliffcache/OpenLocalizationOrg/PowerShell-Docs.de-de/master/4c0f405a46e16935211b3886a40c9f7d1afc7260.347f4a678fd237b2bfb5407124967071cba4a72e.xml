{"nodes":[{"pos":[12,53],"content":"Creating .NET and COM Objects  New Object","needQuote":true,"nodes":[{"content":"Creating .NET and COM Objects  New Object","pos":[0,41]}]},{"pos":[87,104],"content":"powershell,cmdlet","needQuote":true,"nodes":[{"content":"powershell,cmdlet","pos":[0,17]}]},{"content":"Creating .NET and COM Objects (New-Object)","pos":[252,294]},{"content":"There are software components with .NET Framework and COM interfaces that enable you to perform many system administration tasks.","pos":[295,424]},{"content":"Windows PowerShell lets you use these components, so you are not limited to the tasks that can be performed by using cmdlets.","pos":[425,550]},{"content":"Many of the cmdlets in the initial release of Windows PowerShell do not work against remote computers.","pos":[551,653]},{"content":"We will demonstrate how to get around this limitation when managing event logs by using the .NET Framework <bpt id=\"p1\">**</bpt>System.Diagnostics.EventLog<ept id=\"p1\">**</ept> class directly from Windows PowerShell.","pos":[654,832],"source":" We will demonstrate how to get around this limitation when managing event logs by using the .NET Framework **System.Diagnostics.EventLog** class directly from Windows PowerShell."},{"content":"Using New-Object for Event Log Access","pos":[838,875]},{"content":"The .NET Framework Class Library includes a class named <bpt id=\"p1\">**</bpt>System.Diagnostics.EventLog<ept id=\"p1\">**</ept> that can be used to manage event logs.","pos":[876,1002],"source":"The .NET Framework Class Library includes a class named **System.Diagnostics.EventLog** that can be used to manage event logs."},{"content":"You can create a new instance of a .NET Framework class by using the <bpt id=\"p1\">**</bpt>New-Object<ept id=\"p1\">**</ept> cmdlet with the <bpt id=\"p2\">**</bpt>TypeName<ept id=\"p2\">**</ept> parameter.","pos":[1003,1126],"source":" You can create a new instance of a .NET Framework class by using the **New-Object** cmdlet with the **TypeName** parameter."},{"content":"For example, the following command creates an event log reference:","pos":[1127,1193]},{"content":"Although the command has created an instance of the EventLog class, the instance does not include any data.","pos":[1360,1467]},{"content":"That is because we did not specify a particular event log.","pos":[1468,1526]},{"content":"How do you get a real event log?","pos":[1527,1559]},{"content":"Using Constructors with New-Object","pos":[1566,1600]},{"content":"To refer to a specific event log, you need to specify the name of the log.","pos":[1601,1675]},{"content":"<bpt id=\"p1\">**</bpt>New-Object<ept id=\"p1\">**</ept> has an <bpt id=\"p2\">**</bpt>ArgumentList<ept id=\"p2\">**</ept> parameter.","pos":[1676,1725],"source":"**New-Object** has an **ArgumentList** parameter."},{"content":"The arguments you pass as values to this parameter are used by a special startup method of the object.","pos":[1726,1828]},{"content":"The method is called a <bpt id=\"p1\">*</bpt>constructor<ept id=\"p1\">*</ept> because it is used to construct the object.","pos":[1829,1909],"source":" The method is called a *constructor* because it is used to construct the object."},{"content":"For example, to get a reference to the Application log, you specify the string 'Application' as an argument:","pos":[1910,2018]},{"pos":[2265,2606],"content":"[!NOTE]\nSince most of the .NET Framework core classes are contained in the System namespace, Windows PowerShell will automatically attempt to find classes you specify in the System namespace if it cannot find a match for the typename you specify. This means that you can specify Diagnostics.EventLog instead of System.Diagnostics.EventLog.","leadings":["","> "],"nodes":[{"content":"Since most of the .NET Framework core classes are contained in the System namespace, Windows PowerShell will automatically attempt to find classes you specify in the System namespace if it cannot find a match for the typename you specify. This means that you can specify Diagnostics.EventLog instead of System.Diagnostics.EventLog.","pos":[8,339],"nodes":[{"content":"Since most of the .NET Framework core classes are contained in the System namespace, Windows PowerShell will automatically attempt to find classes you specify in the System namespace if it cannot find a match for the typename you specify.","pos":[0,238]},{"content":"This means that you can specify Diagnostics.EventLog instead of System.Diagnostics.EventLog.","pos":[239,331]}]}]},{"content":"Storing Objects in Variables","pos":[2613,2641]},{"content":"You might want to store a reference to an object, so you can use it in the current shell.","pos":[2642,2731]},{"content":"Although Windows PowerShell lets you do a lot of work with pipelines, lessening the need for variables, sometimes storing references to objects in variables makes it more convenient to manipulate those objects.","pos":[2732,2942]},{"content":"Windows PowerShell lets you create variables that are essentially named objects.","pos":[2944,3024]},{"content":"The output from any valid Windows PowerShell command can be stored in a variable.","pos":[3025,3106]},{"content":"Variable names always begin with $.","pos":[3107,3142]},{"content":"If you want to store the Application log reference in a variable named $AppLog, type the name of the variable, followed by an equal sign and then type the command used to create the Application log object:","pos":[3143,3348]},{"content":"If you then type $AppLog, you can see that it contains the Application log:","pos":[3448,3523]},{"content":"Accessing a Remote Event Log with New-Object","pos":[3712,3756]},{"content":"The commands used in the preceding section target the local computer; the <bpt id=\"p1\">**</bpt>Get-EventLog<ept id=\"p1\">**</ept> cmdlet can do that.","pos":[3757,3867],"source":"The commands used in the preceding section target the local computer; the **Get-EventLog** cmdlet can do that."},{"content":"To access the Application log on a remote computer, you must supply both the log name and a computer name (or IP address) as arguments.","pos":[3868,4003]},{"content":"Now that we have a reference to an event log stored in the $RemoteAppLog variable, what tasks can we perform on it?","pos":[4287,4402]},{"content":"Clearing an Event Log with Object Methods","pos":[4409,4450]},{"content":"Objects often have methods that can be called to perform tasks.","pos":[4451,4514]},{"content":"You can use <bpt id=\"p1\">**</bpt>Get-Member<ept id=\"p1\">**</ept> to display the methods associated with an object.","pos":[4515,4591],"source":" You can use **Get-Member** to display the methods associated with an object."},{"content":"The following command and selected output show some the methods of the EventLog class:","pos":[4592,4678]},{"content":"The <bpt id=\"p1\">**</bpt>Clear()<ept id=\"p1\">**</ept> method can be used to clear the event log.","pos":[5449,5507],"source":"The **Clear()** method can be used to clear the event log."},{"content":"When calling a method, you must always follow the method name by parentheses, even if the method does not require arguments.","pos":[5508,5632]},{"content":"This lets Windows PowerShell distinguish between the method and a potential property with the same name.","pos":[5633,5737]},{"content":"Type the following to call the <bpt id=\"p1\">**</bpt>Clear<ept id=\"p1\">**</ept> method:","pos":[5738,5786],"source":" Type the following to call the **Clear** method:"},{"content":"Type the following to display the log.","pos":[5823,5861]},{"content":"You will see that the event log was cleared, and now has 0 entries instead of 262:","pos":[5862,5944]},{"content":"Creating COM Objects with New-Object","pos":[6138,6174]},{"content":"You can use <bpt id=\"p1\">**</bpt>New-Object<ept id=\"p1\">**</ept> to work with Component Object Model (COM) components.","pos":[6175,6255],"source":"You can use **New-Object** to work with Component Object Model (COM) components."},{"content":"Components range from the various libraries included with Windows Script Host (WSH) to ActiveX applications such as Internet Explorer that are installed on most systems.","pos":[6256,6425]},{"content":"<bpt id=\"p1\">**</bpt>New-Object<ept id=\"p1\">**</ept> uses .NET Framework Runtime-Callable Wrappers to create COM objects, so it has the same limitations that .NET Framework does when calling COM objects.","pos":[6427,6592],"source":"**New-Object** uses .NET Framework Runtime-Callable Wrappers to create COM objects, so it has the same limitations that .NET Framework does when calling COM objects."},{"content":"To create a COM object, you need to specify the <bpt id=\"p1\">**</bpt>ComObject<ept id=\"p1\">**</ept> parameter with the Programmatic Identifier or <bpt id=\"p2\">*</bpt>ProgId<ept id=\"p2\">*</ept> of the COM class you want to use.","pos":[6593,6743],"source":" To create a COM object, you need to specify the **ComObject** parameter with the Programmatic Identifier or *ProgId* of the COM class you want to use."},{"content":"A complete discussion of the limitations of COM use and determining what ProgIds are available on a system is beyond the scope of this user's guide, but most well-known objects from environments such as WSH can be used within Windows PowerShell.","pos":[6744,6989]},{"content":"You can create the WSH objects by specifying these progids: <bpt id=\"p1\">**</bpt>WScript.Shell<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>WScript.Network<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>Scripting.Dictionary<ept id=\"p3\">**</ept>, and <bpt id=\"p4\">**</bpt>Scripting.FileSystemObject<ept id=\"p4\">**</ept>.","pos":[6991,7152],"source":"You can create the WSH objects by specifying these progids: **WScript.Shell**, **WScript.Network**, **Scripting.Dictionary**, and **Scripting.FileSystemObject**."},{"content":"The following commands create these objects:","pos":[7153,7197]},{"content":"Although most of the functionality of these classes is made available in other ways in Windows PowerShell, a few tasks such as shortcut creation are still easier to do using the WSH classes.","pos":[7374,7564]},{"content":"Creating a Desktop Shortcut with WScript.Shell","pos":[7570,7616]},{"content":"One task that can be performed quickly with a COM object is creating a shortcut.","pos":[7617,7697]},{"content":"Suppose you want to create a shortcut on your desktop that links to the home folder for Windows PowerShell.","pos":[7698,7805]},{"content":"You first need to create a reference to <bpt id=\"p1\">**</bpt>WScript.Shell<ept id=\"p1\">**</ept>, which we will store in a variable named <bpt id=\"p2\">**</bpt>$WshShell<ept id=\"p2\">**</ept>:","pos":[7806,7919],"source":" You first need to create a reference to **WScript.Shell**, which we will store in a variable named **$WshShell**:"},{"content":"Get-Member works with COM objects, so you can explore the members of the object by typing:","pos":[7978,8068]},{"content":"<bpt id=\"p1\">**</bpt>Get-Member<ept id=\"p1\">**</ept> has an optional <bpt id=\"p2\">**</bpt>InputObject<ept id=\"p2\">**</ept> parameter you can use instead of piping to provide input to <bpt id=\"p3\">**</bpt>Get-Member<ept id=\"p3\">**</ept>.","pos":[8459,8581],"source":"**Get-Member** has an optional **InputObject** parameter you can use instead of piping to provide input to **Get-Member**."},{"content":"You would get the same output as shown above if you instead used the command <bpt id=\"p1\">**</bpt>Get-Member -InputObject $WshShell<ept id=\"p1\">**</ept>.","pos":[8582,8697],"source":" You would get the same output as shown above if you instead used the command **Get-Member -InputObject $WshShell**."},{"content":"If you use <bpt id=\"p1\">**</bpt>InputObject<ept id=\"p1\">**</ept>, it treats its argument as a single item.","pos":[8698,8766],"source":" If you use **InputObject**, it treats its argument as a single item."},{"content":"This means that if you have several objects in a variable, <bpt id=\"p1\">**</bpt>Get-Member<ept id=\"p1\">**</ept> treats them as an array of objects.","pos":[8767,8876],"source":" This means that if you have several objects in a variable, **Get-Member** treats them as an array of objects."},{"content":"For example:","pos":[8877,8889]},{"content":"The <bpt id=\"p1\">**</bpt>WScript.Shell CreateShortcut<ept id=\"p1\">**</ept> method accepts a single argument, the path to the shortcut file to create.","pos":[9118,9229],"source":"The **WScript.Shell CreateShortcut** method accepts a single argument, the path to the shortcut file to create."},{"content":"We could type in the full path to the desktop, but there is an easier way.","pos":[9230,9304]},{"content":"The desktop is normally represented by a folder named Desktop inside the home folder of the current user.","pos":[9305,9410]},{"content":"Windows PowerShell has a variable <bpt id=\"p1\">**</bpt>$Home<ept id=\"p1\">**</ept> that contains the path to this folder.","pos":[9411,9493],"source":" Windows PowerShell has a variable **$Home** that contains the path to this folder."},{"content":"We can specify the path to the home folder by using this variable, and then add the name of the Desktop folder and the name for the shortcut to create by typing:","pos":[9494,9655]},{"content":"When you use something that looks like a variable name inside double-quotes, Windows PowerShell tries to substitute a matching value.","pos":[9726,9859]},{"content":"If you use single-quotes, Windows PowerShell does not try to substitute the variable value.","pos":[9860,9951]},{"content":"For example, try typing the following commands:","pos":[9952,9999]},{"content":"We now have a variable named <bpt id=\"p1\">**</bpt>$lnk<ept id=\"p1\">**</ept> that contains a new shortcut reference.","pos":[10146,10223],"source":"We now have a variable named **$lnk** that contains a new shortcut reference."},{"content":"If you want to see its members, you can pipe it to <bpt id=\"p1\">**</bpt>Get-Member<ept id=\"p1\">**</ept>.","pos":[10224,10290],"source":" If you want to see its members, you can pipe it to **Get-Member**."},{"content":"The output below shows the members we need to use to finish creating our shortcut:","pos":[10291,10373]},{"content":"PS&gt; $lnk | Get-Member TypeName: System.__ComObject#{f935dc23-1cf0-11d0-adb9-00c04fd58a0b} Name             MemberType   Definition ----             ----------   ---------- ... Save             Method       void Save () ... TargetPath       Property     string TargetPath () {get} {set} ...","pos":[10380,10669],"source":"PS> $lnk | Get-Member\nTypeName: System.__ComObject#{f935dc23-1cf0-11d0-adb9-00c04fd58a0b}\nName             MemberType   Definition\n----             ----------   ----------\n...\nSave             Method       void Save ()\n...\nTargetPath       Property     string TargetPath () {get} {set}\n..."},{"content":"We need to specify the <bpt id=\"p1\">**</bpt>TargetPath<ept id=\"p1\">**</ept>, which is the application folder for Windows PowerShell, and then save the shortcut <bpt id=\"p2\">**</bpt>$lnk<ept id=\"p2\">**</ept> by calling the <bpt id=\"p3\">**</bpt>Save<ept id=\"p3\">**</ept> method.","pos":[10677,10839],"source":"We need to specify the **TargetPath**, which is the application folder for Windows PowerShell, and then save the shortcut **$lnk** by calling the **Save** method."},{"content":"The Windows PowerShell application folder path is stored in the variable <bpt id=\"p1\">**</bpt>$PSHome<ept id=\"p1\">**</ept>, so we can do this by typing:","pos":[10840,10954],"source":" The Windows PowerShell application folder path is stored in the variable **$PSHome**, so we can do this by typing:"},{"content":"$lnk.TargetPath = $PSHome $lnk.Save()","pos":[10961,10998],"source":"$lnk.TargetPath = $PSHome\n$lnk.Save()"},{"content":"Using Internet Explorer from Windows PowerShell","pos":[11010,11057]},{"content":"Many applications (including the Microsoft Office family of applications and Internet Explorer) can be automated by using COM.","pos":[11058,11184]},{"content":"Internet Explorer illustrates some of the typical techniques and issues involved in working with COM-based applications.","pos":[11185,11305]},{"pos":[11307,11425],"content":"You create an Internet Explorer instance by specifying the Internet Explorer ProgId, <bpt id=\"p1\">**</bpt>InternetExplorer.Application<ept id=\"p1\">**</ept>:","source":"You create an Internet Explorer instance by specifying the Internet Explorer ProgId, **InternetExplorer.Application**:"},{"content":"This command starts Internet Explorer, but does not make it visible.","pos":[11493,11561]},{"content":"If you type Get-Process, you can see that a process named iexplore is running.","pos":[11562,11640]},{"content":"In fact, if you exit Windows PowerShell, the process will continue to run.","pos":[11641,11715]},{"content":"You must reboot the computer or use a tool like Task Manager to end the iexplore process.","pos":[11716,11805]},{"pos":[11809,12157],"content":"[!NOTE]\nCOM objects that start as separate processes, commonly called *ActiveX executables*, may or may not display a user interface window when they start up. If they create a window but do not make it visible, like Internet Explorer, the focus will generally move to the Windows desktop and you must make the window visible to interact with it.","leadings":["","> "],"nodes":[{"content":"COM objects that start as separate processes, commonly called *ActiveX executables*, may or may not display a user interface window when they start up. If they create a window but do not make it visible, like Internet Explorer, the focus will generally move to the Windows desktop and you must make the window visible to interact with it.","pos":[8,346],"nodes":[{"content":"COM objects that start as separate processes, commonly called <bpt id=\"p1\">*</bpt>ActiveX executables<ept id=\"p1\">*</ept>, may or may not display a user interface window when they start up.","pos":[0,151],"source":"COM objects that start as separate processes, commonly called *ActiveX executables*, may or may not display a user interface window when they start up."},{"content":"If they create a window but do not make it visible, like Internet Explorer, the focus will generally move to the Windows desktop and you must make the window visible to interact with it.","pos":[152,338]}]}]},{"content":"By typing <bpt id=\"p1\">**</bpt>$ie | Get-Member<ept id=\"p1\">**</ept>, you can view properties and methods for Internet Explorer.","pos":[12159,12249],"source":"By typing **$ie | Get-Member**, you can view properties and methods for Internet Explorer."},{"content":"To see the Internet Explorer window, set the Visible property to $true by typing:","pos":[12250,12331]},{"content":"You can then navigate to a specific Web address by using the Navigate method:","pos":[12362,12439]},{"content":"Using other members of the Internet Explorer object model, it is possible to retrieve text content from the Web page.","pos":[12525,12642]},{"content":"The following command will display the HTML text in the body of the current Web page:","pos":[12643,12728]},{"content":"To close Internet Explorer from within PowerShell, call its Quit() method:","pos":[12767,12841]},{"content":"This will force it to close.","pos":[12863,12891]},{"content":"The $ie variable no longer contains a valid reference even though it still appears to be a COM object.","pos":[12892,12994]},{"content":"If you attempt to use it, you will get an automation error:","pos":[12995,13054]},{"content":"You can either remove the remaining reference with a command like $ie = $null, or completely remove the variable by typing:","pos":[13333,13456]},{"pos":[13488,13945],"content":"[!NOTE]\nThere is no common standard for whether ActiveX executables exit or continue to run when you remove a reference to one. Depending on circumstances such as whether the application is visible, whether an edited document is running in it, and even whether Windows PowerShell is still running, the application may or may not exit. For this reason, you should test termination behavior for each ActiveX executable you want to use in Windows PowerShell.","leadings":["","> "],"nodes":[{"content":"There is no common standard for whether ActiveX executables exit or continue to run when you remove a reference to one. Depending on circumstances such as whether the application is visible, whether an edited document is running in it, and even whether Windows PowerShell is still running, the application may or may not exit. For this reason, you should test termination behavior for each ActiveX executable you want to use in Windows PowerShell.","pos":[8,455],"nodes":[{"content":"There is no common standard for whether ActiveX executables exit or continue to run when you remove a reference to one.","pos":[0,119]},{"content":"Depending on circumstances such as whether the application is visible, whether an edited document is running in it, and even whether Windows PowerShell is still running, the application may or may not exit.","pos":[120,326]},{"content":"For this reason, you should test termination behavior for each ActiveX executable you want to use in Windows PowerShell.","pos":[327,447]}]}]},{"content":"Getting Warnings About .NET Framework-Wrapped COM Objects","pos":[13951,14008]},{"content":"In some cases, a COM object might have an associated .NET Framework <bpt id=\"p1\">*</bpt>Runtime-Callable Wrapper<ept id=\"p1\">*</ept> or RCW, and this will be used by <bpt id=\"p2\">**</bpt>New-Object<ept id=\"p2\">**</ept>.","pos":[14009,14152],"source":"In some cases, a COM object might have an associated .NET Framework *Runtime-Callable Wrapper* or RCW, and this will be used by **New-Object**."},{"content":"Since the behavior of the RCW may be different from the behavior of the normal COM object, <bpt id=\"p1\">**</bpt>New-Object<ept id=\"p1\">**</ept> has a <bpt id=\"p2\">**</bpt>Strict<ept id=\"p2\">**</ept> parameter to warn you about RCW access.","pos":[14153,14315],"source":" Since the behavior of the RCW may be different from the behavior of the normal COM object, **New-Object** has a **Strict** parameter to warn you about RCW access."},{"content":"If you specify the <bpt id=\"p1\">**</bpt>Strict<ept id=\"p1\">**</ept> parameter and then create a COM object that uses an RCW, you get a warning message:","pos":[14316,14429],"source":" If you specify the **Strict** parameter and then create a COM object that uses an RCW, you get a warning message:"},{"content":"Although the object is still created, you are warned that it is not a standard COM object.","pos":[14927,15017]}],"content":"---\ntitle:  Creating .NET and COM Objects  New Object \nms.date:  2016-05-11\nkeywords:  powershell,cmdlet\ndescription:  \nms.topic:  article\nauthor:  jpjofre\nmanager:  dongill\nms.prod:  powershell\nms.assetid:  2057b113-efeb-465e-8b44-da2f20dbf603\n---\n\n# Creating .NET and COM Objects (New-Object)\nThere are software components with .NET Framework and COM interfaces that enable you to perform many system administration tasks. Windows PowerShell lets you use these components, so you are not limited to the tasks that can be performed by using cmdlets. Many of the cmdlets in the initial release of Windows PowerShell do not work against remote computers. We will demonstrate how to get around this limitation when managing event logs by using the .NET Framework **System.Diagnostics.EventLog** class directly from Windows PowerShell.\n\n### Using New-Object for Event Log Access\nThe .NET Framework Class Library includes a class named **System.Diagnostics.EventLog** that can be used to manage event logs. You can create a new instance of a .NET Framework class by using the **New-Object** cmdlet with the **TypeName** parameter. For example, the following command creates an event log reference:\n\n```\nPS> New-Object -TypeName System.Diagnostics.EventLog\n\n  Max(K) Retain OverflowAction        Entries Name\n  ------ ------ --------------        ------- ----\n```\n\nAlthough the command has created an instance of the EventLog class, the instance does not include any data. That is because we did not specify a particular event log. How do you get a real event log?\n\n#### Using Constructors with New-Object\nTo refer to a specific event log, you need to specify the name of the log. **New-Object** has an **ArgumentList** parameter. The arguments you pass as values to this parameter are used by a special startup method of the object. The method is called a *constructor* because it is used to construct the object. For example, to get a reference to the Application log, you specify the string 'Application' as an argument:\n\n```\nPS> New-Object -TypeName System.Diagnostics.EventLog -ArgumentList Application\n\nMax(K) Retain OverflowAction        Entries Name\n------ ------ --------------        ------- ----\n16,384      7 OverwriteOlder          2,160 Application\n```\n\n> [!NOTE]\n> Since most of the .NET Framework core classes are contained in the System namespace, Windows PowerShell will automatically attempt to find classes you specify in the System namespace if it cannot find a match for the typename you specify. This means that you can specify Diagnostics.EventLog instead of System.Diagnostics.EventLog.\n\n#### Storing Objects in Variables\nYou might want to store a reference to an object, so you can use it in the current shell. Although Windows PowerShell lets you do a lot of work with pipelines, lessening the need for variables, sometimes storing references to objects in variables makes it more convenient to manipulate those objects.\n\nWindows PowerShell lets you create variables that are essentially named objects. The output from any valid Windows PowerShell command can be stored in a variable. Variable names always begin with $. If you want to store the Application log reference in a variable named $AppLog, type the name of the variable, followed by an equal sign and then type the command used to create the Application log object:\n\n```\nPS> $AppLog = New-Object -TypeName System.Diagnostics.EventLog -ArgumentList Application\n```\n\nIf you then type $AppLog, you can see that it contains the Application log:\n\n```\nPS> $AppLog\n\n  Max(K) Retain OverflowAction        Entries Name\n  ------ ------ --------------        ------- ----\n  16,384      7 OverwriteOlder          2,160 Application\n```\n\n#### Accessing a Remote Event Log with New-Object\nThe commands used in the preceding section target the local computer; the **Get-EventLog** cmdlet can do that. To access the Application log on a remote computer, you must supply both the log name and a computer name (or IP address) as arguments.\n\n```\nPS> $RemoteAppLog = New-Object -TypeName System.Diagnostics.EventLog Application,192.168.1.81\nPS> $RemoteAppLog\n\n  Max(K) Retain OverflowAction        Entries Name\n  ------ ------ --------------        ------- ----\n     512      7 OverwriteOlder            262 Application\n```\n\nNow that we have a reference to an event log stored in the $RemoteAppLog variable, what tasks can we perform on it?\n\n#### Clearing an Event Log with Object Methods\nObjects often have methods that can be called to perform tasks. You can use **Get-Member** to display the methods associated with an object. The following command and selected output show some the methods of the EventLog class:\n\n```\nPS> $RemoteAppLog | Get-Member -MemberType Method\n\n   TypeName: System.Diagnostics.EventLog\n\nName                      MemberType Definition\n----                      ---------- ----------\n...\nClear                     Method     System.Void Clear()\nClose                     Method     System.Void Close()\n...\nGetType                   Method     System.Type GetType()\n...\nModifyOverflowPolicy      Method     System.Void ModifyOverflowPolicy(Overfl...\nRegisterDisplayName       Method     System.Void RegisterDisplayName(String ...\n...\nToString                  Method     System.String ToString()\nWriteEntry                Method     System.Void WriteEntry(String message),...\nWriteEvent                Method     System.Void WriteEvent(EventInstance in...\n```\n\nThe **Clear()** method can be used to clear the event log. When calling a method, you must always follow the method name by parentheses, even if the method does not require arguments. This lets Windows PowerShell distinguish between the method and a potential property with the same name. Type the following to call the **Clear** method:\n\n```\nPS> $RemoteAppLog.Clear()\n```\n\nType the following to display the log. You will see that the event log was cleared, and now has 0 entries instead of 262:\n\n```\nPS> $RemoteAppLog\n\n  Max(K) Retain OverflowAction        Entries Name\n  ------ ------ --------------        ------- ----\n     512      7 OverwriteOlder              0 Application\n```\n\n### Creating COM Objects with New-Object\nYou can use **New-Object** to work with Component Object Model (COM) components. Components range from the various libraries included with Windows Script Host (WSH) to ActiveX applications such as Internet Explorer that are installed on most systems.\n\n**New-Object** uses .NET Framework Runtime-Callable Wrappers to create COM objects, so it has the same limitations that .NET Framework does when calling COM objects. To create a COM object, you need to specify the **ComObject** parameter with the Programmatic Identifier or *ProgId* of the COM class you want to use. A complete discussion of the limitations of COM use and determining what ProgIds are available on a system is beyond the scope of this user's guide, but most well-known objects from environments such as WSH can be used within Windows PowerShell.\n\nYou can create the WSH objects by specifying these progids: **WScript.Shell**, **WScript.Network**, **Scripting.Dictionary**, and **Scripting.FileSystemObject**. The following commands create these objects:\n\n```\nNew-Object -ComObject WScript.Shell\nNew-Object -ComObject WScript.Network\nNew-Object -ComObject Scripting.Dictionary\nNew-Object -ComObject Scripting.FileSystemObject\n```\n\nAlthough most of the functionality of these classes is made available in other ways in Windows PowerShell, a few tasks such as shortcut creation are still easier to do using the WSH classes.\n\n### Creating a Desktop Shortcut with WScript.Shell\nOne task that can be performed quickly with a COM object is creating a shortcut. Suppose you want to create a shortcut on your desktop that links to the home folder for Windows PowerShell. You first need to create a reference to **WScript.Shell**, which we will store in a variable named **$WshShell**:\n\n```\n$WshShell = New-Object -ComObject WScript.Shell\n```\n\nGet-Member works with COM objects, so you can explore the members of the object by typing:\n\n```\nPS> $WshShell | Get-Member\n\n   TypeName: System.__ComObject#{41904400-be18-11d3-a28b-00104bd35090}\n\nName                     MemberType            Definition\n----                     ----------            ----------\nAppActivate              Method                bool AppActivate (Variant, Va...\nCreateShortcut           Method                IDispatch CreateShortcut (str...\n...\n```\n\n**Get-Member** has an optional **InputObject** parameter you can use instead of piping to provide input to **Get-Member**. You would get the same output as shown above if you instead used the command **Get-Member -InputObject $WshShell**. If you use **InputObject**, it treats its argument as a single item. This means that if you have several objects in a variable, **Get-Member** treats them as an array of objects. For example:\n\n```\nPS> $a = 1,2,\"three\"\nPS> Get-Member -InputObject $a\nTypeName: System.Object[]\nName               MemberType    Definition\n----               ----------    ----------\nCount              AliasProperty Count = Length\n...\n```\n\nThe **WScript.Shell CreateShortcut** method accepts a single argument, the path to the shortcut file to create. We could type in the full path to the desktop, but there is an easier way. The desktop is normally represented by a folder named Desktop inside the home folder of the current user. Windows PowerShell has a variable **$Home** that contains the path to this folder. We can specify the path to the home folder by using this variable, and then add the name of the Desktop folder and the name for the shortcut to create by typing:\n\n```\n$lnk = $WshShell.CreateShortcut(\"$Home\\Desktop\\PSHome.lnk\")\n```\n\nWhen you use something that looks like a variable name inside double-quotes, Windows PowerShell tries to substitute a matching value. If you use single-quotes, Windows PowerShell does not try to substitute the variable value. For example, try typing the following commands:\n\n```\nPS> \"$Home\\Desktop\\PSHome.lnk\"\nC:\\Documents and Settings\\aka\\Desktop\\PSHome.lnk\nPS> '$Home\\Desktop\\PSHome.lnk'\n$Home\\Desktop\\PSHome.lnk\n```\n\nWe now have a variable named **$lnk** that contains a new shortcut reference. If you want to see its members, you can pipe it to **Get-Member**. The output below shows the members we need to use to finish creating our shortcut:\n\n<pre>PS> $lnk | Get-Member\nTypeName: System.__ComObject#{f935dc23-1cf0-11d0-adb9-00c04fd58a0b}\nName             MemberType   Definition\n----             ----------   ----------\n...\nSave             Method       void Save ()\n...\nTargetPath       Property     string TargetPath () {get} {set}\n...</pre>\n\nWe need to specify the **TargetPath**, which is the application folder for Windows PowerShell, and then save the shortcut **$lnk** by calling the **Save** method. The Windows PowerShell application folder path is stored in the variable **$PSHome**, so we can do this by typing:\n\n<pre>$lnk.TargetPath = $PSHome\n$lnk.Save()</pre>\n\n### Using Internet Explorer from Windows PowerShell\nMany applications (including the Microsoft Office family of applications and Internet Explorer) can be automated by using COM. Internet Explorer illustrates some of the typical techniques and issues involved in working with COM-based applications.\n\nYou create an Internet Explorer instance by specifying the Internet Explorer ProgId, **InternetExplorer.Application**:\n\n```\n$ie = New-Object -ComObject InternetExplorer.Application\n```\n\nThis command starts Internet Explorer, but does not make it visible. If you type Get-Process, you can see that a process named iexplore is running. In fact, if you exit Windows PowerShell, the process will continue to run. You must reboot the computer or use a tool like Task Manager to end the iexplore process.\n\n> [!NOTE]\n> COM objects that start as separate processes, commonly called *ActiveX executables*, may or may not display a user interface window when they start up. If they create a window but do not make it visible, like Internet Explorer, the focus will generally move to the Windows desktop and you must make the window visible to interact with it.\n\nBy typing **$ie | Get-Member**, you can view properties and methods for Internet Explorer. To see the Internet Explorer window, set the Visible property to $true by typing:\n\n```\n$ie.Visible = $true\n```\n\nYou can then navigate to a specific Web address by using the Navigate method:\n\n```\n$ie.Navigate(\"http://www.microsoft.com/technet/scriptcenter/default.mspx\")\n```\n\nUsing other members of the Internet Explorer object model, it is possible to retrieve text content from the Web page. The following command will display the HTML text in the body of the current Web page:\n\n```\n$ie.Document.Body.InnerText\n```\n\nTo close Internet Explorer from within PowerShell, call its Quit() method:\n\n```\n$ie.Quit()\n```\n\nThis will force it to close. The $ie variable no longer contains a valid reference even though it still appears to be a COM object. If you attempt to use it, you will get an automation error:\n\n```\nPS> $ie | Get-Member\nGet-Member : Exception retrieving the string representation for property \"Appli\ncation\" : \"The object invoked has disconnected from its clients. (Exception fro\nm HRESULT: 0x80010108 (RPC_E_DISCONNECTED))\"\nAt line:1 char:16\n+ $ie | Get-Member <<<<\n```\n\nYou can either remove the remaining reference with a command like $ie = $null, or completely remove the variable by typing:\n\n```\nRemove-Variable ie\n```\n\n> [!NOTE]\n> There is no common standard for whether ActiveX executables exit or continue to run when you remove a reference to one. Depending on circumstances such as whether the application is visible, whether an edited document is running in it, and even whether Windows PowerShell is still running, the application may or may not exit. For this reason, you should test termination behavior for each ActiveX executable you want to use in Windows PowerShell.\n\n### Getting Warnings About .NET Framework-Wrapped COM Objects\nIn some cases, a COM object might have an associated .NET Framework *Runtime-Callable Wrapper* or RCW, and this will be used by **New-Object**. Since the behavior of the RCW may be different from the behavior of the normal COM object, **New-Object** has a **Strict** parameter to warn you about RCW access. If you specify the **Strict** parameter and then create a COM object that uses an RCW, you get a warning message:\n\n```\nPS> $xl = New-Object -ComObject Excel.Application -Strict\nNew-Object : The object written to the pipeline is an instance of the type \"Mic\nrosoft.Office.Interop.Excel.ApplicationClass\" from the component's primary inte\nrop assembly. If this type exposes different members than the IDispatch members\n, scripts written to work with this object might not work if the primary intero\np assembly is not installed.\nAt line:1 char:17\n+ $xl = New-Object  <<<< -ComObject Excel.Application -Strict\n```\n\nAlthough the object is still created, you are warned that it is not a standard COM object.\n\n"}