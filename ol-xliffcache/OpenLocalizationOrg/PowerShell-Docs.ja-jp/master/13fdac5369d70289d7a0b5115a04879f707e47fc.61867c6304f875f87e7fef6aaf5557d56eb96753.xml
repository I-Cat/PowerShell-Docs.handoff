{"nodes":[{"pos":[12,47],"content":"Working with Software Installations","needQuote":true,"nodes":[{"content":"Working with Software Installations","pos":[0,35]}]},{"pos":[80,97],"content":"powershell,cmdlet","needQuote":true,"nodes":[{"content":"powershell,cmdlet","pos":[0,17]}]},{"content":"Working with Software Installations","pos":[245,280]},{"content":"Applications that are designed to use Windows Installer can be accessed through WMI's <bpt id=\"p1\">**</bpt>Win32_Product<ept id=\"p1\">**</ept> class, but not all applications in use today use the Windows Installer.","pos":[281,456],"source":"Applications that are designed to use Windows Installer can be accessed through WMI's **Win32_Product** class, but not all applications in use today use the Windows Installer."},{"content":"Because the Windows Installer provides the widest range of standard techniques for working with installable applications, we will focus primarily on those applications.","pos":[457,625]},{"content":"Applications that use alternate setup routines will generally not be managed by the Windows Installer.","pos":[626,728]},{"content":"Specific techniques for working with those applications will depend on the installer software and decisions made by the application developer.","pos":[729,871]},{"pos":[875,1165],"content":"[!NOTE]\nApplications that are installed by copying the application files to the computer usually cannot be managed by using techniques discussed here. You can manage these applications as files and folders by using the techniques discussed in the \"Working With Files and Folders\" section.","leadings":["","> "],"nodes":[{"content":"Applications that are installed by copying the application files to the computer usually cannot be managed by using techniques discussed here. You can manage these applications as files and folders by using the techniques discussed in the \"Working With Files and Folders\" section.","pos":[8,288],"nodes":[{"content":"Applications that are installed by copying the application files to the computer usually cannot be managed by using techniques discussed here.","pos":[0,142]},{"content":"You can manage these applications as files and folders by using the techniques discussed in the \"Working With Files and Folders\" section.","pos":[143,280]}]}]},{"content":"Listing Windows Installer Applications","pos":[1171,1209]},{"content":"To list the applications installed with the Windows Installer on a local or remote system, use the following simple WMI query:","pos":[1210,1336]},{"content":"To display all of the properties of the Win32_Product object to the display, use the Properties parameter of the formatting cmdlets, such as the Format-List cmdlet, with a value of \\* (all).","pos":[1631,1821]},{"content":"Or, you could use the <bpt id=\"p1\">**</bpt>Get-WmiObject Filter<ept id=\"p1\">**</ept> parameter to select only Microsoft .NET Framework 2.0.","pos":[2454,2555],"source":"Or, you could use the **Get-WmiObject Filter** parameter to select only Microsoft .NET Framework 2.0."},{"content":"Because the filter used in this command is a WMI filter, it uses WMI Query Language (WQL) syntax, not Windows PowerShell syntax.","pos":[2556,2684]},{"content":"Instead,:","pos":[2685,2694]},{"content":"Note that WQL queries frequently use characters, such as spaces or equal signs, that have a special meaning in Windows PowerShell.","pos":[2827,2957]},{"content":"For this reason, it is prudent to always enclose the value of the Filter parameter in quotation marks.","pos":[2958,3060]},{"content":"You can also use the Windows PowerShell escape character, a backtick (\\`), although it may not improve readability.","pos":[3061,3176]},{"content":"The following command is equivalent to the previous command and returns the same results, but uses the backtick to escape special characters, instead of quoting the entire filter string.","pos":[3177,3363]},{"content":"To list only the properties that interest you, use the Property parameter of the formatting cmdlets to list the desired properties.","pos":[3501,3632]},{"pos":[4162,4278],"content":"Finally, to find only the names of installed applications, a simple <bpt id=\"p1\">**</bpt>Format-Wide<ept id=\"p1\">**</ept> statement simplifies the output:","source":"Finally, to find only the names of installed applications, a simple **Format-Wide** statement simplifies the output:"},{"content":"Although we now have several ways to look at applications that used the Windows Installer for installation, we have not considered other applications.","pos":[4365,4515]},{"content":"Because most standard applications register their uninstaller with Windows, we can work with those locally by finding them in the Windows registry.","pos":[4516,4663]},{"content":"Listing All Uninstallable Applications","pos":[4669,4707]},{"content":"Although there is no guaranteed way to find every application on a system, it is possible to find all programs with listings displayed in the Add or Remove Programs dialog box.","pos":[4708,4884]},{"content":"Add or Remove Programs finds these applications in the following registry key:","pos":[4885,4963]},{"pos":[4965,5045],"content":"<bpt id=\"p1\">**</bpt>HKEY_LOCAL_MACHINE\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall<ept id=\"p1\">**</ept>.","source":"**HKEY_LOCAL_MACHINE\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall**."},{"content":"We can also examine this key to find applications.","pos":[5047,5097]},{"content":"To make it easier to view the Uninstall key, we can map a Windows PowerShell drive to this registry location:","pos":[5098,5207]},{"pos":[5450,5842],"content":"[!NOTE]\nThe **HKLM:** drive is mapped to the root of **HKEY_LOCAL_MACHINE**, so we used that drive in the path to the Uninstall key. Instead of **HKLM:** we could have specified the registry path by using either **HKLM** or **HKEY_LOCAL_MACHINE**. The advantage of using an existing registry drive is that we can use tab-completion to fill in the keys names, so we do not need to type them.","leadings":["","> "],"nodes":[{"content":"The **HKLM:** drive is mapped to the root of **HKEY_LOCAL_MACHINE**, so we used that drive in the path to the Uninstall key. Instead of **HKLM:** we could have specified the registry path by using either **HKLM** or **HKEY_LOCAL_MACHINE**. The advantage of using an existing registry drive is that we can use tab-completion to fill in the keys names, so we do not need to type them.","pos":[8,390],"nodes":[{"content":"The <bpt id=\"p1\">**</bpt>HKLM:<ept id=\"p1\">**</ept> drive is mapped to the root of <bpt id=\"p2\">**</bpt>HKEY_LOCAL_MACHINE<ept id=\"p2\">**</ept>, so we used that drive in the path to the Uninstall key.","pos":[0,124],"source":"The **HKLM:** drive is mapped to the root of **HKEY_LOCAL_MACHINE**, so we used that drive in the path to the Uninstall key."},{"content":"Instead of <bpt id=\"p1\">**</bpt>HKLM:<ept id=\"p1\">**</ept> we could have specified the registry path by using either <bpt id=\"p2\">**</bpt>HKLM<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>HKEY_LOCAL_MACHINE<ept id=\"p3\">**</ept>.","pos":[125,239],"source":" Instead of **HKLM:** we could have specified the registry path by using either **HKLM** or **HKEY_LOCAL_MACHINE**."},{"content":"The advantage of using an existing registry drive is that we can use tab-completion to fill in the keys names, so we do not need to type them.","pos":[240,382]}]}]},{"content":"We now have a drive named \"Uninstall\" that can be used to quickly and conveniently look for application installations.","pos":[5844,5962]},{"content":"We can find the number of installed applications by counting the number of registry keys in the Uninstall: Windows PowerShell drive:","pos":[5963,6095]},{"content":"We can search this list of applications further by using a variety of techniques, beginning with <bpt id=\"p1\">**</bpt>Get-ChildItem<ept id=\"p1\">**</ept>.","pos":[6153,6268],"source":"We can search this list of applications further by using a variety of techniques, beginning with **Get-ChildItem**."},{"content":"To get a list of applications and save them in the <bpt id=\"p1\">**</bpt>$UninstallableApplications<ept id=\"p1\">**</ept> variable, use the following command:","pos":[6269,6387],"source":" To get a list of applications and save them in the **$UninstallableApplications** variable, use the following command:"},{"pos":[6460,6763],"content":"[!NOTE]\nWe are using a lengthy variable name here for clarity. In actual use, there is no reason to use long names. Although you can use tab-completion for variable names, you can also use 1–2 character names for speed. Longer, descriptive names are most useful when you are developing code for reuse.","leadings":["","> "],"nodes":[{"content":"We are using a lengthy variable name here for clarity. In actual use, there is no reason to use long names. Although you can use tab-completion for variable names, you can also use 1–2 character names for speed. Longer, descriptive names are most useful when you are developing code for reuse.","pos":[8,301],"nodes":[{"content":"We are using a lengthy variable name here for clarity.","pos":[0,54]},{"content":"In actual use, there is no reason to use long names.","pos":[55,107]},{"content":"Although you can use tab-completion for variable names, you can also use 1–2 character names for speed.","pos":[108,211]},{"content":"Longer, descriptive names are most useful when you are developing code for reuse.","pos":[212,293]}]}]},{"content":"To display the values of the registry entries in the registry keys under Uninstall, use the GetValue method of the registry keys.","pos":[6765,6894]},{"content":"The value of the method is the name of the registry entry.","pos":[6895,6953]},{"content":"For example, to find the display names of applications in the Uninstall key, use the following command:","pos":[6955,7058]},{"content":"There is no guarantee that these values are unique.","pos":[7161,7212]},{"content":"In the following example, two installed items appear as \"Windows Media Encoder 9 Series\":","pos":[7213,7302]},{"content":"Installing Applications","pos":[7823,7846]},{"pos":[7847,7946],"content":"You can use the <bpt id=\"p1\">**</bpt>Win32_Product<ept id=\"p1\">**</ept> class to install Windows Installer packages, remotely or locally.","source":"You can use the **Win32_Product** class to install Windows Installer packages, remotely or locally."},{"pos":[7950,8130],"content":"[!NOTE]\nOn Windows Vista, Windows Server 2008, and later versions of Windows, to install an application, you must start Windows PowerShell with the \"Run as administrator\" option.","leadings":["","> "],"nodes":[{"content":"On Windows Vista, Windows Server 2008, and later versions of Windows, to install an application, you must start Windows PowerShell with the \"Run as administrator\" option.","pos":[8,178]}]},{"content":"When installing remotely, use a Universal Naming Convention (UNC) network path to specify the path to the .msi package, because the WMI subsystem does not understand Windows PowerShell paths.","pos":[8132,8323]},{"content":"For example, to install the NewPackage.msi package located in the network share \\\\\\\\AppServ\\\\dsp on the remote computer PC01, type the following command at the Windows PowerShell prompt:","pos":[8324,8510]},{"content":"Applications that do not use Windows Installer technology may have application-specific methods available for automated deployment.","pos":[8658,8789]},{"content":"To determine whether there is a method for deployment automation, check the documentation for the application or consult the application vendor's support system.","pos":[8790,8951]},{"content":"In some cases, even if the application vendor did not specifically design the application for installation automation, the installer software manufacturer may have some techniques for automation.","pos":[8952,9147]},{"content":"Removing Applications","pos":[9153,9174]},{"content":"Removing a Windows Installer package by using Windows PowerShell works in approximately the same way as installing a package.","pos":[9175,9300]},{"content":"Here is an example that selects the package to uninstall based on its name; in some cases it may be easier to filter with the <bpt id=\"p1\">**</bpt>IdentifyingNumber<ept id=\"p1\">**</ept>:","pos":[9301,9449],"source":" Here is an example that selects the package to uninstall based on its name; in some cases it may be easier to filter with the **IdentifyingNumber**:"},{"content":"Removing other applications is not quite so simple, even when done locally.","pos":[9551,9626]},{"content":"We can find the command line uninstallation strings for these applications by extracting the <bpt id=\"p1\">**</bpt>UninstallString<ept id=\"p1\">**</ept> property.","pos":[9627,9749],"source":" We can find the command line uninstallation strings for these applications by extracting the **UninstallString** property."},{"content":"This method works for Windows Installer applications and for older programs appearing under the Uninstall key:","pos":[9750,9860]},{"content":"You can filter the output by the display name, if you like:","pos":[9963,10022]},{"content":"However, these strings may not be directly usable from the Windows PowerShell prompt without some modification.","pos":[10197,10308]},{"content":"Upgrading Windows Installer Applications","pos":[10314,10354]},{"content":"To upgrade an application, you need to know the name of the application and the path to the application upgrade package.","pos":[10355,10475]},{"content":"With that information, you can upgrade an application with a single Windows PowerShell command:","pos":[10476,10571]}],"content":"---\ntitle:  Working with Software Installations\nms.date:  2016-05-11\nkeywords:  powershell,cmdlet\ndescription:  \nms.topic:  article\nauthor:  jpjofre\nmanager:  dongill\nms.prod:  powershell\nms.assetid:  51a12fe9-95f6-4ffc-81a5-4fa72a5bada9\n---\n\n# Working with Software Installations\nApplications that are designed to use Windows Installer can be accessed through WMI's **Win32_Product** class, but not all applications in use today use the Windows Installer. Because the Windows Installer provides the widest range of standard techniques for working with installable applications, we will focus primarily on those applications. Applications that use alternate setup routines will generally not be managed by the Windows Installer. Specific techniques for working with those applications will depend on the installer software and decisions made by the application developer.\n\n> [!NOTE]\n> Applications that are installed by copying the application files to the computer usually cannot be managed by using techniques discussed here. You can manage these applications as files and folders by using the techniques discussed in the \"Working With Files and Folders\" section.\n\n### Listing Windows Installer Applications\nTo list the applications installed with the Windows Installer on a local or remote system, use the following simple WMI query:\n\n```\nPS> Get-WmiObject -Class Win32_Product -ComputerName .\nIdentifyingNumber : {7131646D-CD3C-40F4-97B9-CD9E4E6262EF}\nName              : Microsoft .NET Framework 2.0\nVendor            : Microsoft Corporation\nVersion           : 2.0.50727\nCaption           : Microsoft .NET Framework 2.0\n```\n\nTo display all of the properties of the Win32_Product object to the display, use the Properties parameter of the formatting cmdlets, such as the Format-List cmdlet, with a value of \\* (all).\n\n```\nPS> Get-WmiObject -Class Win32_Product -ComputerName . | Where-Object -FilterScript {$_.Name -eq \"Microsoft .NET Framework 2.0\"} | Format-List -Property *\nName              : Microsoft .NET Framework 2.0\nVersion           : 2.0.50727\nInstallState      : 5\nCaption           : Microsoft .NET Framework 2.0\nDescription       : Microsoft .NET Framework 2.0\nIdentifyingNumber : {7131646D-CD3C-40F4-97B9-CD9E4E6262EF}\nInstallDate       : 20060506\nInstallDate2      : 20060506000000.000000-000\nInstallLocation   :\nPackageCache      : C:\\WINDOWS\\Installer\\619ab2.msi\nSKUNumber         :\nVendor            : Microsoft Corporation\n```\n\nOr, you could use the **Get-WmiObject Filter** parameter to select only Microsoft .NET Framework 2.0. Because the filter used in this command is a WMI filter, it uses WMI Query Language (WQL) syntax, not Windows PowerShell syntax. Instead,:\n\n```\nGet-WmiObject -Class Win32_Product -ComputerName . -Filter \"Name='Microsoft .NET Framework 2.0'\"| Format-List -Property *\n```\n\nNote that WQL queries frequently use characters, such as spaces or equal signs, that have a special meaning in Windows PowerShell. For this reason, it is prudent to always enclose the value of the Filter parameter in quotation marks. You can also use the Windows PowerShell escape character, a backtick (\\`), although it may not improve readability. The following command is equivalent to the previous command and returns the same results, but uses the backtick to escape special characters, instead of quoting the entire filter string.\n\n```\nGet-WmiObject -Class Win32_Product -ComputerName . -Filter Name`=`'Microsoft` .NET` Framework` 2.0`' | Format-List -Property *\n```\n\nTo list only the properties that interest you, use the Property parameter of the formatting cmdlets to list the desired properties.\n\n```\nGet-WmiObject -Class Win32_Product -ComputerName . | Format-List -Property Name,InstallDate,InstallLocation,PackageCache,Vendor,Version,IdentifyingNumber\n...\nName              : HighMAT Extension to Microsoft Windows XP CD Writing Wizard\nInstallDate       : 20051022\nInstallLocation   : C:\\Program Files\\HighMAT CD Writing Wizard\\\nPackageCache      : C:\\WINDOWS\\Installer\\113b54.msi\nVendor            : Microsoft Corporation\nVersion           : 1.1.1905.1\nIdentifyingNumber : {FCE65C4E-B0E8-4FBD-AD16-EDCBE6CD591F}\n...\n```\n\nFinally, to find only the names of installed applications, a simple **Format-Wide** statement simplifies the output:\n\n```\nGet-WmiObject -Class Win32_Product -ComputerName .  | Format-Wide -Column 1\n```\n\nAlthough we now have several ways to look at applications that used the Windows Installer for installation, we have not considered other applications. Because most standard applications register their uninstaller with Windows, we can work with those locally by finding them in the Windows registry.\n\n### Listing All Uninstallable Applications\nAlthough there is no guaranteed way to find every application on a system, it is possible to find all programs with listings displayed in the Add or Remove Programs dialog box. Add or Remove Programs finds these applications in the following registry key:\n\n**HKEY_LOCAL_MACHINE\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall**.\n\nWe can also examine this key to find applications. To make it easier to view the Uninstall key, we can map a Windows PowerShell drive to this registry location:\n\n```\nPS>    \n\nName       Provider      Root                                   CurrentLocation\n----       --------      ----                                   ---------------\nUninstall  Registry      HKEY_LOCAL_MACHINE\\SOFTWARE\\Micr...\n```\n\n> [!NOTE]\n> The **HKLM:** drive is mapped to the root of **HKEY_LOCAL_MACHINE**, so we used that drive in the path to the Uninstall key. Instead of **HKLM:** we could have specified the registry path by using either **HKLM** or **HKEY_LOCAL_MACHINE**. The advantage of using an existing registry drive is that we can use tab-completion to fill in the keys names, so we do not need to type them.\n\nWe now have a drive named \"Uninstall\" that can be used to quickly and conveniently look for application installations. We can find the number of installed applications by counting the number of registry keys in the Uninstall: Windows PowerShell drive:\n\n```\nPS> (Get-ChildItem -Path Uninstall:).Count\n459\n```\n\nWe can search this list of applications further by using a variety of techniques, beginning with **Get-ChildItem**. To get a list of applications and save them in the **$UninstallableApplications** variable, use the following command:\n\n```\n$UninstallableApplications = Get-ChildItem -Path Uninstall:\n```\n\n> [!NOTE]\n> We are using a lengthy variable name here for clarity. In actual use, there is no reason to use long names. Although you can use tab-completion for variable names, you can also use 1–2 character names for speed. Longer, descriptive names are most useful when you are developing code for reuse.\n\nTo display the values of the registry entries in the registry keys under Uninstall, use the GetValue method of the registry keys. The value of the method is the name of the registry entry.\n\nFor example, to find the display names of applications in the Uninstall key, use the following command:\n\n```\nPS> Get-ChildItem -Path Uninstall: | ForEach-Object -Process { $_.GetValue(\"DisplayName\") }\n```\n\nThere is no guarantee that these values are unique. In the following example, two installed items appear as \"Windows Media Encoder 9 Series\":\n\n```\nPS> Get-ChildItem -Path Uninstall: | Where-Object -FilterScript { $_.GetValue(\"DisplayName\") -eq \"Windows Media Encoder 9 Series\"}\n\n   Hive: Microsoft.PowerShell.Core\\Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Micros\noft\\Windows\\CurrentVersion\\Uninstall\n\nSKC  VC Name                           Property\n---  -- ----                           --------\n  0   3 Windows Media Encoder 9        {DisplayName, DisplayIcon, UninstallS...\n  0  24 {E38C00D0-A68B-4318-A8A6-F7... {AuthorizedCDFPrefix, Comments, Conta...\n```\n\n### Installing Applications\nYou can use the **Win32_Product** class to install Windows Installer packages, remotely or locally.\n\n> [!NOTE]\n> On Windows Vista, Windows Server 2008, and later versions of Windows, to install an application, you must start Windows PowerShell with the \"Run as administrator\" option.\n\nWhen installing remotely, use a Universal Naming Convention (UNC) network path to specify the path to the .msi package, because the WMI subsystem does not understand Windows PowerShell paths. For example, to install the NewPackage.msi package located in the network share \\\\\\\\AppServ\\\\dsp on the remote computer PC01, type the following command at the Windows PowerShell prompt:\n\n```\n(Get-WMIObject -ComputerName PC01 -List | Where-Object -FilterScript {$_.Name -eq \"Win32_Product\"}).Install(\\\\AppSrv\\dsp\\NewPackage.msi)\n```\n\nApplications that do not use Windows Installer technology may have application-specific methods available for automated deployment. To determine whether there is a method for deployment automation, check the documentation for the application or consult the application vendor's support system. In some cases, even if the application vendor did not specifically design the application for installation automation, the installer software manufacturer may have some techniques for automation.\n\n### Removing Applications\nRemoving a Windows Installer package by using Windows PowerShell works in approximately the same way as installing a package. Here is an example that selects the package to uninstall based on its name; in some cases it may be easier to filter with the **IdentifyingNumber**:\n\n```\n(Get-WmiObject -Class Win32_Product -Filter \"Name='ILMerge'\" -ComputerName . ).Uninstall()\n```\n\nRemoving other applications is not quite so simple, even when done locally. We can find the command line uninstallation strings for these applications by extracting the **UninstallString** property. This method works for Windows Installer applications and for older programs appearing under the Uninstall key:\n\n```\nGet-ChildItem -Path Uninstall: | ForEach-Object -Process { $_.GetValue(\"UninstallString\") }\n```\n\nYou can filter the output by the display name, if you like:\n\n```\nGet-ChildItem -Path Uninstall: | Where-Object -FilterScript { $_.GetValue(\"DisplayName\") -like \"Win*\"} | ForEach-Object -Process { $_.GetValue(\"UninstallString\") }\n```\n\nHowever, these strings may not be directly usable from the Windows PowerShell prompt without some modification.\n\n### Upgrading Windows Installer Applications\nTo upgrade an application, you need to know the name of the application and the path to the application upgrade package. With that information, you can upgrade an application with a single Windows PowerShell command:\n\n```\n(Get-WmiObject -Class Win32_Product -ComputerName . -Filter \"Name='OldAppName'\").Upgrade(\\\\AppSrv\\dsp\\OldAppUpgrade.msi)\n```\n\n"}